#!/bin/bash
################################################################################
# A part of TINKTEP, an interface between ONETEP and TINKER.                   #
# Jacek Dziedzic, University of Southampton, May-December 2015.                #
################################################################################

################################################################################
# *** key_process ***
# Processes a .key file generated by POLEDIT from ONETEP GDMA-like file by
# - renumbering QM sites so that they do not clash with AMOEBA atom types,
# - renumbering QM multipoles accordingly,
# - adding dummy 'bond' and 'angle' terms between QM sites,
# - adding 'polarizable' for MM atoms, which makes *QM* atoms 'formally polarisable',
#   meaning they benefit from Thole damping, but have zero induced dipoles.
# - merging in the contents of the main key file.
# - substituting poledit's guesses for polarisabilities with suitable values
#   inferred from the .xyz and .prm files.
# - adding other directives ('DEBUG" and 'OPENMP-THREADS').
#
# v1.61
# Jacek Dziedzic, April-November 2015.
################################################################################
# Revision history:
# v1.01 2015.05.21 -- Adds 'inactive'.
# v1.02 2015.07.08 -- Adds 'polarizable'.
# v1.05 2015.07.14 -- Correctly renumbers polarisation group neighbour types.
# v1.10 2015.07.20 -- Optional QM/MM vdW terms.
# v1.11 2015.09.11 -- Renumber_offset moved to config file.
# v1.13 2015.11.12 -- Adds 'DEBUG' to key file, TINKER threads.
# v1.15 2015.11.22 -- Crucial 'abs' to support negated atom types.
# v1.16 2015.11.24 -- Does not add 'OPENMP-THREADS' if omitted.
# v1.20 2015.11.24 -- Crucial not-offseting of zeros in multipoles.
# v1.30 2015.11.25 -- Polarisabilities obtained from .prm used in place of 
#                     poledit's guesses.
# v1.32 2016.01.14 -- Free-form vdw lines in .key files supported.
# v1.33 2016.01.14 -- Ditto for polarize lines.
# v1.35 2016.01.14 -- Ditto for atom lines, somewhat more tricky.
# v1.36 2016.03.22 -- Explicitly disallows zero MM atoms (TINKER would hang).
#                     Zero MM atoms still works with 'pure_qm', where key_process
#                     is never invoked.
# v1.40 2016.04.29 -- Support for fixed-charge force fields.
# v1.45 2016.05.06 -- Uses Thole a from the config file, or TINKER's default if not specified.
# v1.46 2016.05.10 -- Fixed limitation to 999 atoms in fixed-charge FFs.
#                     Added trap for current limit of 9999 atoms in poledit.
# v1.47 2016.10.28 -- Trailing spaces stripped from jobname.
# v1.48 2016.11.16 -- Renamed qm_polarisabilities to qm.polarisabilities.
# v1.49 2017.03.16 -- Handles corner case of empty QM region.
# v1.52 2017.05.12 -- Supports 'qm_dummy_atoms'.
# v1.55 2017.09.21 -- Supports 'qm_mm_polscal'.
# v1.56 2017.09.21 -- Renaming of keywords to 'qm_mm_polscal', 'qm_mm_thole_a'.
# v1.60 2017.09.21 -- 'tinker_qm_mm_vdw_energy' supports settings of '2' and '3' too.
# v1.61 2018.05.05 -- Better handling of omitted 'tinker_qm_mm_vdw_energy'.
################################################################################

myname="key_process"
configfile="tinktep.config"
dummy_atom_symbol="J"

#-------------------------------------------------------------------------------
# Aborts, printing a message and returning an error code.
#-------------------------------------------------------------------------------
function error() {
  echo "!!! $myname: ERROR #$2: $1. Aborting!" >&2
  exit $2
}
#-------------------------------------------------------------------------------

################################################################################
# Error codes
################################################################################
err_improper_invocation=101
err_config_file=102
err_input_poledit_key_bad_extension=103
err_input_main_key_bad_extension=104
err_key_file_already_exits=105
err_input_poledit_key_unreadable=106
err_input_main_key_unreadable=107
err_input_tag_file_unreadable=108
err_removing_polarize_keywords=109
err_adding_dummy_bond_keywords=110
err_adding_dummy_angle_keywords=111
err_renumbering_atom_sites=112
err_renumbering_multipole_sites=113
err_pasting_dummy_bond_keywords=114
err_pasting_dummy_angle_keywords=115
err_adding_inactive_keyword=116
err_renumbering_polarize_keywords=117
err_adding_polarizable_keyword=118
err_input_xyz_file_unreadable=119
err_adding_vdw_keyword=120
err_processing_vdw=121
err_key_missing_parameters=122
err_ff_param_file_unreadable=123
err_processing_vdw_2=124
err_processing_vdw_3=125
err_config_file_directive_renumber_offset=126
err_config_file_directive_tinker_nthreads=127
err_key_missing_parameters=128
err_ff_param_file_unreadable=129
err_config_file_directive_jobname=130
err_failed_to_obtain_qm_polarisability=131
err_no_mm_atoms=132
err_converting_multipoles_to_fixed_charges=133
err_config_file_directive_qm_mm_thole_a=134
err_config_file_qm_polarisability_with_no_qm=135
err_config_file_qm_polarisability_needed_for_qm_dummy_atoms=136
err_bbox_qm_file=137
err_failed_to_obtain_dummy_qm_atom_indices=138
err_config_file_directive_qm_mm_polscal=139
err_config_file_directive_tinker_qm_mm_vdw_energy=140

#-------------------------------------------------------------------------------
# Parses the config file
#-------------------------------------------------------------------------------
function parse_config() {
  if [ ! -r $configfile ]; then
    error "Cannot read $configfile" $err_config_file
  fi

  if [ `cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -Ec "^jobname"` != 1 ]; then
    error "Setting 'jobname' is not defined, or is defined multiply, in $configfile" $err_config_file_directive_jobname
  fi
  opt_jobname=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -E "^jobname" | sed "s/jobname //" | sed "s/ *//g"`
  echo "    (jobname: $opt_jobname)"

  opt_qm_polarisability=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -Ec "^qm_polari[sz]ability" | awk '{if($1>0) print "1"; else print "0";}'`
  if [ $opt_qm_polarisability == "1" ]; then
    echo "    (QM polarisability)"
  else
    echo "    (NO QM polarisability)"
  fi

  opt_qm_dummy_atoms=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -Ec "^qm_dummy_atoms" | awk '{if($1>0) print "1"; else print "0";}'`
  if [ $opt_qm_dummy_atoms == "1" ]; then
    echo "    (Dummy QM atoms will be created from MM atoms)"
  fi

  if [ `cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -Ec "^tinker_nthreads"` -gt 1 ]; then
    error "Setting 'tinker_nthreads' is defined multiply, in $configfile" $err_config_file_directive_tinker_nthreads
  fi
  opt_tinker_nthreads=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -E "^tinker_nthreads" | sed "s/tinker_nthreads //"`
  if [ -z $opt_tinker_nthreads ]; then
    reported_tinker_nthreads="unspecified, leaving TINKER in charge"
  else
    reported_tinker_nthreads=$opt_tinker_nthreads
  fi
  echo "    (TINKER number of OMP threads: $reported_tinker_nthreads)"

  if [ `cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -Ec "^renumber_offset"` != 1 ]; then
    error "Setting 'renumber_offset' is not defined, or is defined multiply, in $configfile" $err_config_file_directive_renumber_offset
  fi
  opt_renumber_offset=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -E "^renumber_offset" | sed "s/renumber_offset //"`
  echo "    (Atom type renumbering offset: $opt_renumber_offset)"

  opt_tinker_qm_mm_vdw_energy=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep "^tinker_qm_mm_vdw_energy" | awk '{print $2}'`
  if [ -z "$opt_tinker_qm_mm_vdw_energy" ]; then
    error "Setting 'tinker_qm_mm_vdw_energy' is not defined in $configfile" $err_config_file_directive_tinker_qm_mm_vdw_energy
  elif [ "$opt_tinker_qm_mm_vdw_energy" == "1" ]; then
    echo "    (Key file will be processed to extract QM/MM van der Waals energy from TINKER)"
  elif [ "$opt_tinker_qm_mm_vdw_energy" == "2" ]; then
    echo "    (Key file will be processed to extract QM/MM van der Waals energy from TINKER -- dispersive term only)"
  elif [ "$opt_tinker_qm_mm_vdw_energy" == "3" ]; then
    echo "    (Key file will be processed to extract QM/MM van der Waals energy from TINKER -- repulsive term only)"
  elif [ "$opt_tinker_qm_mm_vdw_energy" == "0" ]; then
    echo "    (Key file will NOT be processed to extract QM/MM van der Waals energy from TINKER)"
  else
    error "Illegal setting for 'tinker_qm_mm_vdw_energy': $opt_tinker_qm_mm_vdw_energy. Legal values are 0, 1, 2 and 3" $err_config_file_directive_tinker_qm_mm_vdw_energy
  fi

  opt_mm_fixed_charge=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -Ec "^mm_fixed_charge" | awk '{if($1>0) print "1"; else print "0";}'`
  if [ $opt_mm_fixed_charge == "1" ]; then
    echo "    (MM uses a fixed-charge force-field)"
  else
    echo "    (MM uses a polarisable force-field)"
  fi

  if [ `cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -Ec "^qm_mm_thole_a"` -gt 1 ]; then
    error "Setting 'qm_mm_thole_a' is defined multiply, in $configfile" $err_config_file_directive_qm_mm_thole_a
  fi
  opt_qm_mm_thole_a=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -E "^qm_mm_thole_a" | sed "s/qm_mm_thole_a //"`
  if [ -z $opt_qm_mm_thole_a ]; then
    opt_qm_mm_thole_a="-1"
  else
    echo "    (QM/MM Thole parameter 'a' overridden to: $opt_qm_mm_thole_a)"
  fi

  if [ `cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -Ec "^qm_mm_polscal"` -gt 1 ]; then
    error "Setting 'qm_mm_polscal' is defined multiply, in $configfile" $err_config_file_directive_qm_mm_polscal
  fi
  opt_qm_mm_polscal=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -E "^qm_mm_polscal" | sed "s/qm_mm_polscal //"`
  if [ -z $opt_qm_mm_polscal ]; then
    opt_qm_mm_polscal="-1"
  else
    echo "    (QM/MM QM-side polarisabilities scaled by: $opt_qm_mm_polscal)"
  fi

  opt_pure_mm=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -Ec "^pure_mm" | awk '{if($1>0) print "1"; else print "0";}'`
  if [ $opt_pure_mm == "1" ]; then
    echo "    (A purely MM run)"
  fi

  # --- Sanity check on combinations of keywords ---
  if [ "$opt_pure_mm" == 1 ]; then
    if [ "$opt_qm_polarisability" == 1 ]; then
       error "'qm_polarisability' is incompatible with 'pure_mm'. If there is no QM, it can't be made polarisable" $err_config_file_qm_polarisability_with_no_qm
    fi
  fi

  if [ "$opt_qm_dummy_atoms" == 1 ]; then
    if [ "$opt_qm_polarisability" == 0 ]; then
       error "'qm_polarisability' must be on when 'qm_dummy_atoms' is used" $err_config_file_qm_polarisability_needed_for_qm_dummy_atoms
    fi
  fi
}

################################################################################
# main()
################################################################################

echo "*** $myname:"

rm -f "error_message"

parse_config

if [ $# -ne 4 ]; then
  error "Improper invocation. Supply four arguments: the name of the POLEDIT-generated key file, the name of the main key file, the name of the .tag file, and the name of the .xyz file" $err_improper_invocation
fi

inkeyfile=$1
inmainkeyfile=$2
intagfile=$3
inxyzfile=$4

# Extract last four characters of input filenames
inkeyfile_ext=`echo $inkeyfile | sed -r "s/.*(....)$/\1/"`
inmainkeyfile_ext=`echo $inmainkeyfile | sed -r "s/.*(....)$/\1/"`

# Ensure they are as expected, for a safe replace later in determining
# the output filenames.
if [ "$inkeyfile_ext" != ".key" ]; then
  error "The extension of the POLEDIT-generated key file should be '.key'" $err_input_poledit_key_bad_extension
fi
if [ "$inmainkeyfile_ext" != ".key" ]; then
  error "The extension of the main key file should be '.key'" $err_input_main_key_bad_extension
fi

# Generate output filenames
outkeyfile=`echo $inmainkeyfile | sed -r "s/\.key$/_qm_mm.key/"`

padding=`echo $myname | sed "s/./ /g"`" "
echo "    $padding Input POLEDIT-generated key file: $inkeyfile."
echo "    $padding Input main key file:              $inmainkeyfile."
echo "    $padding Input .tag file:                  $intagfile."
echo "    $padding Input .xyz file:                  $inxyzfile."

# Ensure output file does not exist
if [ -e $outkeyfile ]; then
  error "$outkeyfile already exists, I'm afraid to overwrite it" $err_key_file_already_exits
fi

echo "    $padding Output QM/MM key file:            $outkeyfile."

# Ensure input files exist and are readable
if [ ! -r $inkeyfile ]; then
  error "$inkeyfile does not exist or is not readable" $err_input_poledit_key_unreadable
fi

if [ ! -r $inmainkeyfile ]; then
  error "$inmainkeyfile does not exist or is not readable" $err_input_main_key_unreadable
fi

if [ ! -r $intagfile ]; then
  error "$intagfile does not exist or is not readable" $err_input_tag_file_unreadable
fi

if [ ! -r $inxyzfile ]; then
  error "$inxyzfile does not exist or is not readable" $err_input_xyz_file_unreadable
fi

# Obtain the name of the FF param file and ensure it exists
FFparamfile=`cat $inmainkeyfile | tr "\t" " " | sed -r "s/ +/ /g" | grep "parameters" | sed "s/parameters //"`".prm"
if [ -z "$FFparamfile" ]; then
  error "The directive 'parameters' is missing in TINKER key file $opt_jobname.key" $err_key_missing_parameters
fi
if [ ! -r "$FFparamfile" ]; then
  error "The force-field parameter file '$FFparamfile' does not exist or is unreadable" $err_ff_param_file_unreadable
fi


# Obtain QM atom indices, handling "-1" correctly
if [ `cat $intagfile | head -n 1 | tr "\t" " " | sed -r "s/ +//g"` == "-1" ]; then
  # QM region empty (tag file contains -1 modulo whitespace)
  qm_atom_indices=""
else
  qm_atom_indices=`cat $intagfile | head -n 1`
fi

# If QM dummy atoms are in use, obtain a list that includes these too, by scanning the QM .xyz file.
qm_atom_indices_with_dummies="$qm_atom_indices"
if [ "$opt_qm_dummy_atoms" == "1" ]; then
  bbox_line=`xyz_bbox_line $inxyzfile` || error "Could not verify the presence of, or parse, the BBox line in the QM .xyz file $inxyzffile" $err_bbox_qm_file
  bbox_line_present=`echo $bbox_line | awk '{print ($4 > 0)}'`
  let "firstatomline=2+bbox_line_present"
  tail -n +$firstatomline $inxyzfile | awk -v dummy_atom_symbol=$dummy_atom_symbol '{if($2 ~ dummy_atom_symbol) printf(" %s",$1)}' >dummy_atom.indices
  result=$?
  if [ $result -ne 0 ]; then
    error "Failed to obtain dummy QM atom indices from $inxyzfile" $err_failed_to_obtain_dummy_qm_atom_indices
  fi
  qm_atom_indices_with_dummies=`echo $qm_atom_indices`" "`cat dummy_atom.indices`
  rm -f dummy_atom.indices
fi

# --- QM polarisabilities ---
if [ $opt_qm_polarisability == "1" ]; then

  # Figure out the right polarisabilities for QM atoms. Poledit assigns... hardcoded guesses (!).
  rm -f qm.polarisabilities
  echo "Unrecognized error [1] in $myname" >"error_message"
  for QM_atom in $qm_atom_indices_with_dummies; do
    QM_polarisability=`atom_number_to_polarisability $inxyzfile $intagfile -$QM_atom $FFparamfile`
    result=$?
    if [ $result -ne 0 ]; then
      errmsg=`cat error_message`
      error "(code $result) Failed to obtain polarisability for QM atom index '$QM_atom': $errmsg" $err_failed_to_obtain_qm_polarisability
    else
      rm -f "error_message"
    fi
    # No converstion from A^3 to a0^3, as this stays tinker-side, but strip comment that atom_number_to_polarisability attaches
    QM_polarisability=`echo $QM_polarisability | awk '{printf("%16.12f",$1)}'`
    if [ -z "$QM_polarisability" ]; then
      error "Failed to obtain polarisability for QM atom index '$QM_atom' for reasons unknown" $err_failed_to_obtain_qm_polarisability
    fi
    echo -n $QM_polarisability " ">>qm.polarisabilities
  done
  rm -f "error_message"

  # Retain 'polarize' on QM atoms, just renumber their types and the types of their polgroup neighbours.
  # Also replace poledit's guesses with the right polarisabilities just obtained.
  cat $inkeyfile | awk -v offset=$opt_renumber_offset -v opt_qm_mm_thole_a="$opt_qm_mm_thole_a" -v opt_qm_mm_polscal="$opt_qm_mm_polscal" '
  BEGIN {
    getline qm_polarisabilities < "qm.polarisabilities";
    n_qm_indices=split(qm_polarisabilities,qm_polarisabilities_arr," ");
    qm_atom_ord=0;
  }
  {
    if($1 == "polarize") {
      qm_atom_ord++;
      qm_polarisability=qm_polarisabilities_arr[qm_atom_ord];
      # The below matches polarize followed by whitespace followed by an integer followed by whitespace 
      # followed by (a crude representation of) a real number followed by same.
      # This lets us skip the first four columns regardless of formatting, while preserving the formatting in the tail of the line. 
      pos=match($0,"polarize[ \t]+[0-9]+[ \t]+[0-9+-.DE]+[ \t]+[0-9+-.DE]+");
      skip=RLENGTH+2;
      tinkers_thole_a=$4;
      if(opt_qm_mm_thole_a == "-1") {
        thole_a = tinkers_thole_a;
      }
      else {
        thole_a = opt_qm_mm_thole_a;
      }
      if(opt_qm_mm_polscal == "-1") {
        qm_polscaled_polarisability = qm_polarisability;
      }
      else {
        qm_polscaled_polarisability = qm_polarisability * opt_qm_mm_polscal;
      }
      printf("polarize   %4d     %11.6f %10.4f %s\n",$2+offset,qm_polscaled_polarisability,thole_a,substr($0,skip));
    }
    else print $0;
  }' >$outkeyfile.1
  result=$?
  if [ $result -ne 0 ]; then
    error "Failed to renumber 'polarize' keywords from $inkeyfile, writing output to $outkeyfile.1" $err_renumbering_polarize_keywords
  fi
else
  # Remove 'polarize' on QM atoms
  cat $inkeyfile | grep -vE "^polarize" >$outkeyfile.1
  result=$?
  if [ $result -ne 0 ]; then
    error "Failed to remove 'polarize' keywords from $inkeyfile, writing output to $outkeyfile.1" $err_removing_polarize_keywords
  fi
fi

# Use connectivity info from 'polarize' in the original file to generate 
# zero 'bond' keywords for QM atoms. We always print out the lower index
# first, so that sort/uniq takes cares of i-j being a duplicate for j-i.
cat $inkeyfile | awk -v offset=$opt_renumber_offset '
function min2(x,y) {
  return x<y ? x : y;
}
function max2(x,y) {
  return x>y ? x : y;
}
{
  if($1 == "polarize") {
    atom_idx=$2;
    atom_idx_renumbered=atom_idx+offset;
    for(neigh_col=5; neigh_col<=NF; ++neigh_col) {
      neigh_idx=$neigh_col;
      neigh_idx_renumbered=neigh_idx+offset;
      lower_idx_renumbered=min2(atom_idx_renumbered,neigh_idx_renumbered);
      higher_idx_renumbered=max2(atom_idx_renumbered,neigh_idx_renumbered);
      printf("bond       %4d %4d%s\n",lower_idx_renumbered,higher_idx_renumbered,"            0.00     0.0000");
    }
  }
}' | sort -gk2,3 | uniq >$outkeyfile.bond
if [ $result -ne 0 ]; then
  error "Failed to generate dummy 'bond' keywords from $inkeyfile, writing output to $outkeyfile.bond" $err_adding_dummy_bond_keywords
fi

# Use connectivity info from 'polarize' in the original file to generate 
# dummy 'angle' keywords for QM atoms. Tinker uses 0.0 to identify missing angle terms,
# so we set the angle to 1.00, keeping the bending constant 0.0
# The convention is to print lower neighbour first, then our atom, then high neighbour.
# No sort/unique is necessary.
cat $inkeyfile | awk -v offset=$opt_renumber_offset '
function min2(x,y) {
  return x<y ? x : y;
}
function max2(x,y) {
  return x>y ? x : y;
}
{
  if($1 == "polarize") {
    atom_idx=$2;
    atom_idx_renumbered=atom_idx+offset;
    for(neigh1_col=5; neigh1_col<=NF; ++neigh1_col) {
      neigh1_idx=$neigh1_col;
      neigh1_idx_renumbered=neigh1_idx+offset;
      for(neigh2_col=neigh1_col+1; neigh2_col<=NF; ++neigh2_col) {
        neigh2_idx=$neigh2_col;
        neigh2_idx_renumbered=neigh2_idx+offset;
        idx_lo_neigh_renumbered=min2(neigh1_idx_renumbered,neigh2_idx_renumbered);
        idx_hi_neigh_renumbered=max2(neigh1_idx_renumbered,neigh2_idx_renumbered);
        printf("angle      %4d %4d %4d%s\n",idx_lo_neigh_renumbered,atom_idx_renumbered,idx_hi_neigh_renumbered,"       0.00       1.00");
      }
    }
  }
}' >$outkeyfile.angle
if [ $result -ne 0 ]; then
  error "Failed to generate dummy 'angle' keywords from $inkeyfile, writing output to $outkeyfile.angle" $err_adding_dummy_angle_keywords
fi

# Renumber 'atom' sites
cat $outkeyfile.1 | awk -v offset=$opt_renumber_offset '{
  if($1 == "atom") {
    # The below matches a regexp "pw followed by atom followed by pw followed by number followed by pw followed by number followed by pw",
    # where "pw" is potential whitespace. This lets us skip the first three columns regardless of formatting, while
    # preserving the formatting in the tail of the line. This might be important due to things with whitespace potentially present in
    # the atom description between the quotes.
    pos=match($0,"[ \t]*atom[ \t]*[0-9]+[ \t]*[0-9]+[ \t]");
    skip=RLENGTH;
    printf("atom       %4d %4d%s\n",$2+offset,$2+offset,substr($0,skip));
  }
  else print $0;
}' >$outkeyfile.2
result=$?
if [ $result -ne 0 ]; then
  error "Failed to renumber 'atom' keywords from $outkeyfile.1, writing output to $outkeyfile.2" $err_renumbering_atom_sites
fi

# Renumber 'multipole' sites
# NB: 'abs' is crucial, as poledit occasionally conveys extra information in the sign of the atom types
# NB: Not offseting zero (and null) is crucial, as zeros denote different frames.
echo "Unrecognized error [4] in $myname" >"error_message"
cat $outkeyfile.2 | awk -v offset=$opt_renumber_offset '
function abs(x) {if(x>0) return x; else return -x}
{
  if($1 == "multipole") {
    old2=substr($0,12,4)+0;
    old3=substr($0,17,4)+0;
    old4=substr($0,22,4)+0;

    if(old2 != 0) {
      new2 = abs(old2)+offset;
    }
    else {
      new2 = 0;
    }
    if(old3 != 0) {
      new3 = abs(old3)+offset;
    }
    else {
      new3 = 0;
    }
    if(old4 != 0) {
      new4 = abs(old4)+offset;
    }
    else {
      new4 = 0;
    }

    if(new2 == 0) {
      printf("Zero atom index obtained. Probably hit poledit'\''s fixed-format limit of 9999 atoms. Contents of offending line: '\''%s'\''",$0) >"error_message";
      exit 12;
    }
    printf("multipole  %4d %4d %4d%s\n",new2,new3,new4,substr($0,26));
  }
  else print $0;
}' >$outkeyfile.3
result=$?
if [ $result -ne 0 ]; then
  errmsg=`cat error_message`
  error "Failed to renumber 'multipole' keywords from $outkeyfile.2, writing output to $outkeyfile.3: $errmsg" $err_renumbering_multipole_sites
fi
rm -f "error_message"

# If using a fixed charge FF, actually use 'charge' keywords in lieu of 'multipole'.
# This entails dropping 4 lines after every 'multipole' that describe dipoles and qpoles.
echo "Unrecognized error [5] in $myname" >"error_message"
if [ "$opt_mm_fixed_charge" == "1" ]; then
  cat $outkeyfile.3 | awk '
{
  if($1 == "multipole") {
    printf("charge %4d %16.9f\n",$2, $5);
    mpole_block_counter=1;
  }
  else {
    if(mpole_block_counter == 0 || mpole_block_counter > 5) {
      print $0;
    }
    else {
      for(i=1;i<=NF;++i) {
        if($(i)+0.0 != 0.0) {
          printf("Detected a DMA-produced non-charge multipole, while working with a fixed-charge MM force field. Fixed-charge FFs are oblivious to higher-order multipoles: %f",$(i)) >"error_message";
          exit 11;
        }
      }
    }
  }
  if(mpole_block_counter > 0) {
     mpole_block_counter++;
  }
}' >$outkeyfile.3b
  result=$?
  if [ $result -ne 0 ]; then
    errmsg=`cat error_message`
    error "Error converting multipole representation to charge only representation for use with a fixed-charge FF: $errmsg" $err_converting_multipoles_to_fixed_charges
  else
    rm -f "error_message"
  fi
  mv -f $outkeyfile.3b $outkeyfile.3
fi


# Add dummy 'bond' terms
cat $outkeyfile.3 >$outkeyfile.4
cat $outkeyfile.bond >>$outkeyfile.4
result=$?
if [ $result -ne 0 ]; then
  error "Failed to paste dummy bond terms from $outkeyfile.bond, writing output to $outkeyfile.4" $err_pasting_dummy_bond_keywords
fi

# Add dummy 'angle' terms
cat $outkeyfile.4 >$outkeyfile.5
cat $outkeyfile.angle >>$outkeyfile.5
result=$?
if [ $result -ne 0 ]; then
  error "Failed to paste dummy angle terms from $outkeyfile.angle, writing output to $outkeyfile.5" $err_pasting_dummy_angle_keywords
fi

# Make the QM region inactive (if there is a QM region)
cat $outkeyfile.5 >$outkeyfile.6
if [ `cat $intagfile | head -n 1 | tr "\t" " " | sed -r "s/ +//g"` == "-1" ]; then
  # QM region empty (tag file contains -1 modulo whitespace)
  true
else
  echo -e -n "\ninactive " >>$outkeyfile.6
  echo $qm_atom_indices_with_dummies >>$outkeyfile.6
  result=$?
  if [ $result -ne 0 ]; then
    error "Failed to add an 'inactive' directive to $outkeyfile.5, writing output to $outkeyfile.6" $err_adding_inactive_keyword
  fi
  echo -e "" >>$outkeyfile.6
fi

# Make the MM region polarisable (if using a polarisable FF)
# Skip this if there is no QM region, as 'dynamic' explodes if 'polarizable' specifies all atoms. In that case omit it, the default is to make everything polarizable.
cat $outkeyfile.6 >$outkeyfile.7
if [ `cat $intagfile | head -n 1 | tr "\t" " " | sed -r "s/ +//g"` == "-1" ]; then
  # QM region empty (tag file contains -1 modulo whitespace)
  true
else
  if [ "$opt_mm_fixed_charge" == "0" ]; then
    echo -e -n "polarizable " >>$outkeyfile.7
    cat $intagfile | head -n 2 | tail -n 1 >>$outkeyfile.7
    result=$?
    if [ $result -ne 0 ]; then
      error "Failed to add an 'polarizable' directive to $outkeyfile.6, writing output to $outkeyfile.7" $err_adding_polarizable_keyword
    fi
    echo -e "\n\n" >>$outkeyfile.7
  fi
fi

# Ensure there is at least one MM atom. TINKER hangs when all atoms are marked as inactive.
mm_atom_list=`cat $intagfile | head -n 2 | tail -n 1 | awk '{print $1+0}'`
if [ "$mm_atom_list" == "-1" ]; then
  error "Cannot run TINKER with an empty MM region -- it hangs when all atoms are marked as inactive. Add 'pure_qm' to tinktep.config to run a purely QM calculation" $err_no_mm_atoms
fi

# If QM/MM vdW, add vdw terms for QM sites
# - First figure out types of QM atoms in AMOEBA
if [ "$opt_tinker_qm_mm_vdw_energy" != "0" ]; then
  qm_indices=`cat $intagfile | head -n 1`
  echo "Unrecognized error [2] in $myname" >"error_message"
  cat $inxyzfile | awk -v qm_indices="$qm_indices" '
  BEGIN{
    n_qm=split(qm_indices,qm_indices_arr," ");
    # Corner case of empty QM region
    if(qm_indices_arr[1]=="-1") {
      n_qm=0;
    }
  }
  {
    if(NR>1) {
      # check it this is a QM atom
      for(qm_i=1; qm_i<=n_qm; ++qm_i) {
        qm_idx=qm_indices_arr[qm_i];
        # If so, print its AMOEBA type
        if($1 == qm_idx) {
          printf("%d ",$6);
          n_written++;
          break;
        }
      }
    }
  }
  END {
    if(n_written!=n_qm) {
      printf("N_written: %d, N_qm: %d",n_written,n_qm) >"error_message";
      exit 12;
    }
  }' >qm_types
  result=$?
  if [ $result -ne 0 ]; then
    errmsg=`cat error_message`
    error "Mismatch between the number of QM atoms found and expected in QM/MM vdw parameter bookkeeping: $errmsg" $err_processing_vdw
  else
    rm -f "error_message"
  fi

  # - Then figure out the classes using the .prm file
  FFparamfile=`cat $inmainkeyfile | tr "\t" " " | sed -r "s/ +/ /g" | grep "parameters" | sed "s/parameters //"`".prm"
  if [ -z "$FFparamfile" ]; then
    error "The directive 'parameters' is missing in TINKER key file $inmainkeyfile" $err_key_missing_parameters
  fi
  if [ ! -r "$FFparamfile" ]; then
    error "The force-field parameter file '$FFparamfile' does not exist or is unreadable" $err_ff_param_file_unreadable
  fi

  # - Go through the param file, find all atom types, see if any is the one we're looking for, if so, store class
  echo "Unrecognized error [3] in $myname" >"error_message"
  cat "$FFparamfile" | awk '
  BEGIN{
    getline qm_types < "qm_types";
    n_qm_types=split(qm_types,qm_types_arr," ");
  }
  {
    if($1 == "atom") {
      type=$2;
      for(qm_type_i=1; qm_type_i<=n_qm_types; ++qm_type_i) {
        qm_type = qm_types_arr[qm_type_i];
        if(type == qm_type) {
          qm_classes[qm_type_i] = $3;
        }
      }
    }
  }
  END {
    for(qm_type_i=1; qm_type_i<=n_qm_types; ++qm_type_i) {
      printf("%d ", qm_classes[qm_type_i]);
      if(qm_classes[qm_type_i] == 0) {
        printf("Could not find FF class corresponding to type %d", qm_types_arr[qm_type_i]) >"error_message";
        exit 12;
      }
    }
  }
  ' >qm_classes
  result=$?
  if [ $result -ne 0 ]; then
    errmsg=`cat error_message`
    error "Error figuring out FF type<->class mapping in file $FFparamfile: $errmsg" $err_processing_vdw_2
  else
    rm -f "error_message"
  fi

  # - Go over all classes and find corresponding entries in FF file
  cat $outkeyfile.7 >$outkeyfile.8
  n_classes_of_all_qm_atoms=`cat qm_classes | wc -w`
  for qm_atom_i in `seq 1 $n_classes_of_all_qm_atoms`; do
    class=`cat qm_classes | awk -v qm_atom_i=$qm_atom_i '{print $qm_atom_i}'`
    echo "Unrecognized error [4] in $myname" >"error_message"
    cat "$FFparamfile" | awk -v class=$class -v qm_atom_i=$qm_atom_i -v offset=$opt_renumber_offset '
    {
      if($1 == "vdw" && $2 == class) {
        printf("vdw         %-4d %s %s %s\n",counter+offset+qm_atom_i,$3,$4,$5);
        found=1;
      }
    }
    END {
      if(!found) {
        printf("Could not find vdw directive for class %d",class) >"error_message";
        exit 12;
      }
    }' >>$outkeyfile.8
    result=$?
    if [ $result -ne 0 ]; then
      errmsg=`cat error_message`
      error "Error finding vdw parameters in file $FFparamfile: $errmsg" $err_processing_vdw_3
    else
      rm -f "error_message"
    fi
  done
  rm -f qm_classes
  rm -f qm_types

else
  cp $outkeyfile.7 $outkeyfile.8
fi
result=$?
if [ $result -ne 0 ]; then
  error "Failed to take care of QM/MM vdW terms reading $outkeyfile.7, writing output to $outkeyfile.8" $err_adding_vdw_keyword
fi
echo -e "\n\n" >>$outkeyfile.8

echo -e "DEBUG\n" >>$outkeyfile.8
if [ ! -z "$opt_tinker_threads" ]; then
  echo -e "OPENMP-THREADS $opt_tinker_threads">>$outkeyfile.8
fi

# Merge in main key file
echo -e "# --- Keywords copied from main key file ---\n" >$outkeyfile
cat $inmainkeyfile >>$outkeyfile
echo -e "\n# --- Keywords describing the QM sites ---\n" >>$outkeyfile
cat $outkeyfile.8 >>$outkeyfile

rm -f $outkeyfile.1 $outkeyfile.2 $outkeyfile.3 $outkeyfile.4 $outkeyfile.5 $outkeyfile.6 $outkeyfile.7 $outkeyfile.8 $outkeyfile.bond $outkeyfile.angle

echo "    $padding SUCCESS"
