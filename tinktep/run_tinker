#!/bin/bash
################################################################################
# A part of TINKTEP, an interface between ONETEP and TINKER.                   #
# Jacek Dziedzic, University of Southampton, May 2015-February 2017.           #
################################################################################

################################################################################
# *** run_tinker ***
# Runs TINKER's 'analyze' and 'dynamic' and subsequently
# - extracts MM permanent multipoles in the global reference frame,
# - extracts MM induced dipoles in the global reference frame,
# - extracts MM-only energy terms (currently: bond stretch and angle bend),
# - extracts and partitions QM/MM and MM energy terms (electrostatics, vdW),
# - extracts positions of multipoles and polarisabilities.
# - extracts forces.
# - bundles the multipoles, polarisabilities, positions and energy terms into
#   a file readable by ONETEP (except it needs to be coord-translated later).
#
# CAVEATS:
# - Some sections in the parser are currently O(N^2) in the number of MM atoms.
#   This can be improved but will have to wait for later.
#
# v1.98
################################################################################
# Revision history:
# v1.22 2015.07.06 -- uses 2.0 quadrupole conversion factor.
# v1.25 2015.07.15 -- config specifies which terms to use
# v1.30 2015.07.27 -- option to include vdW terms
# v1.31 2015.07.28 -- renamed keywords for consistency
# v1.32 2015.09.11 -- renumber_offset moved to config file
# v1.33 2015.11.12 -- works with updated atom_to_polarisability
# v1.40 2015.11.19 -- improved precision in conversions
# v1.42 2015.11.19 -- improved precision in permanent multipoles
# v1.43 2015.11.24 -- does not attempt to extract angle bending energy if there are <3 MM atoms
# v1.45 2015.12.09 -- 'v' attached to MM valence terms. Improved precision in polarisabilities.
# v1.50 2016.01.14 -- Support for BBox lines in .xyz files.
# v1.52 2016.01.15 -- Bugfix for broken atom offsets resulting in bad induced dipoles,
#                     (bug introduced in v1.50).
# v1.60 2016.04.29 -- Supports fixed-charge force fields.
# v1.61 2016.04.29 -- Message readability improved.
# v1.65 2016.04.29 -- Reduced complexity of TINKER log parsing from O(N^2) to O(N).
# v1.67 2016.05.04 -- Sped up parsing of polarisabilities (which are constant).
# v1.68 2016.09.16 -- User feedback on calculation/re-use of polarisabilities.
# v1.69 2016.09.20 -- Uses "#" in lieu of "*" to denote ignored interactions and mpoles.
# v1.70 2016.10.03 -- QM and MM atoms properly distinguished with '#' in both perm and ind.
# v1.71 2016.10.28 -- Trailing spaces stripped from jobname.
# v1.75 2016.11.15 -- Permanent MM multipoles get polarisabilities too.
# v1.77 2016.11.22 -- Correctly functions if opt_polarisabilities_needed is 0,
#                     i.e. when no Thole damping is needed and when we don't extract any.
# v1.80 2016.11.25 -- Improved output precision.
# v1.82 2017.02.07 -- Extracts Urey-Bradley energy too.
# v1.83 2017.03.06 -- Watches out for '***' in analyze/dynamic log, indicating Fortran overflow.
# v1.84 2017.03.06 -- Correctly handles large induced dipoles (formatting was off).
# v1.85 2017.03.07 -- Fixed syntax error introduced in previous version.
# v1.86 2017.03.16 -- Fixed a missing error message number for error #102.
# v1.90 2017.04.20 -- Separated vdW terms into repulsive and dispersive components.
# v1.91 2017.05.12 -- NaNs detected in analyze/dynamic log.
# v1.92 2017.07.06 -- Asterisk detection ignores lines with dummy atoms.
# v1.93 2017.07.06 -- Ignores dummy atoms when extracting electrostatic energies.
#                     ^ this is disabled now.
# v1.95 2017.09.20 -- Includes vdW params of MM atoms in mpole file.
# v1.97 2017.09.21 -- 'tinker_qm_mm_vdw_energy' supports settings of '2' and '3' too.
# v1.98 2017.09.22 -- Fixed missing vdW params of MM atoms for permanent sets.
################################################################################

myname="run_tinker"
dynamicexe="dynamic"
analyzeexe="analyze"
configfile="tinktep.config"
force_conv_fac=0.0433641                       # from (kcal/mol)/A to eV/A
dipole_conv_fac=0.52917721092                  # from eA to ea0 (inverse factor)
energy_conv_fac=0.0015936014370388925          # from kcal/mol to Ha
induced_dipole_conv_fac=0.39342983641461897071 # from D to ea0
bohr2ang=0.52917721092                         # from a0 to A
dummy_atom_symbol="J"

#-------------------------------------------------------------------------------
# Aborts, printing a message and returning an error code.
function error() {
  echo "!!! $myname: ERROR #$2: $1. Aborting!" >&2
  exit $2
}
#-------------------------------------------------------------------------------

################################################################################
# Error codes
################################################################################
err_improper_invocation=101
err_xyz_file_unreadable=102
err_input_xyz_bad_extension=103
err_key_file_unreadable=104
err_dynamic_log_already_exists=105
err_analyze_log_already_exists=106
err_multp_file_already_exists=107
err_eterm_file_already_exists=108
err_tinker_dynamic_failed=109
err_analyze_error_code=110
err_dynamic_error_code=111
err_extracting_forces=112
err_extracting_permanent_multipoles=113
err_extracting_atomic_positions=114
err_processing_permanent_multipoles=115
err_config_file=116
err_config_file_directive_onetep_perm_mpoles=117
err_processing_induced_qm_mm_dipoles_1=118
err_processing_induced_mm_dipoles_1=119
err_processing_induced_qm_mm_dipoles_2=120
err_processing_induced_mm_dipoles_2=121
err_combining_mpole_files=122
err_extracting_bond_energy=123
err_extracting_angle_energy=124
err_extracting_perm_energy=125
err_extracting_pol_energy=126
err_input_xyz_bad_nametail=127
err_tinker_renumbered_atoms=128
err_bad_multipole_count=129
err_processing_electrostatics=130
err_in_number_of_electrostatics_terms=131
err_processing_non_electrostatics=132
err_in_number_of_non_electrostatics_terms=133
err_config_file_directive_renumber_offset=134
err_key_missing_parameters=135
err_ff_param_file_unreadable=136
err_config_file_directive_jobname=137
err_bbox=138
err_extracting_fixed_charge_QM=139
err_extracting_fixed_charge_MM=140
err_extracting_mm_atom_polarisabilities=141
err_extracting_ureybrad_energy=142
err_analyze_asterisks_in_log=143
err_dynamic_asterisks_in_log=144
err_analyze_NaN_in_log=145
err_dynamic_NaN_in_log=146
err_extracting_mm_atom_vdw_params=147
err_config_file_directive_tinker_qm_mm_vdw_energy=148
err_config_file_directive_tinker_mm_vdw_energy=149

#-------------------------------------------------------------------------------
# Parses the config file
function parse_config() {
  if [ ! -r $configfile ]; then
    error "Cannot read $configfile" $err_config_file
  fi

  if [ `cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -Ec "^jobname"` != 1 ]; then
    error "Setting 'jobname' is not defined, or is defined multiply, in $configfile" $err_config_file_directive_jobname
  fi
  opt_jobname=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -E "^jobname" | sed "s/jobname //" | sed "s/ *//g"`
  echo "    (jobname: $opt_jobname)"

  opt_qm_polarisability=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -Ec "^qm_polari[sz]ability" | awk '{if($1>0) print "1"; else print "0";}'`
  if [ $opt_qm_polarisability == "1" ]; then
    echo "    (QM polarisability)"
  else
    echo "    (NO QM polarisability)"
  fi

  if [ `cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -Ec "^renumber_offset"` != 1 ]; then
    error "Setting 'renumber_offset' is not defined, or is defined multiply, in $configfile" $err_config_file_directive_renumber_offset
  fi
  opt_renumber_offset=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -E "^renumber_offset" | sed "s/renumber_offset //"`
  echo "    (Atom type renumbering offset: $opt_renumber_offset)"

  opt_tinker_bond_energy=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -Ec "^tinker_bond_energy 1" | awk '{if($1>0) print "1"; else print "0";}'`
  if [ $opt_tinker_bond_energy == "1" ]; then
    echo "    (MM Bond energy from TINKER)"
  else
    echo "    (MM Bond energy NOT from TINKER)"
  fi

  opt_tinker_angle_energy=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -Ec "^tinker_angle_energy 1" | awk '{if($1>0) print "1"; else print "0";}'`
  if [ $opt_tinker_angle_energy == "1" ]; then
    echo "    (MM Angle energy from TINKER)"
  else
    echo "    (MM Angle energy NOT from TINKER)"
  fi

  opt_tinker_ureybrad_energy=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -Ec "^tinker_ureybrad_energy 1" | awk '{if($1>0) print "1"; else print "0";}'`
  if [ $opt_tinker_ureybrad_energy == "1" ]; then
    echo "    (MM Urey-Bradley energy from TINKER)"
  else
    echo "    (MM Urey-Bradley energy NOT from TINKER)"
  fi

  opt_tinker_qm_mm_vdw_energy=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep "^tinker_qm_mm_vdw_energy" | awk '{print $2}'`
  if [ $opt_tinker_qm_mm_vdw_energy == "1" ]; then
    echo "    (QM/MM van der Waals energy from TINKER)"
  elif [ $opt_tinker_qm_mm_vdw_energy == "2" ]; then
    echo "    (QM/MM van der Waals energy from TINKER -- dispersive term only)"
  elif [ $opt_tinker_qm_mm_vdw_energy == "3" ]; then
    echo "    (QM/MM van der Waals energy from TINKER -- repulsive term only)"
  elif [ $opt_tinker_qm_mm_vdw_energy == "0" ]; then
    echo "    (QM/MM van der Waals energy NOT from TINKER)"
  else
    error "Illegal setting for tinker_qm_mm_vdw_energy: $opt_tinker_qm_mm_vdw_energy. Legal values are 0, 1, 2 and 3." $err_config_file_directive_tinker_qm_mm_vdw_energy
  fi

  opt_tinker_mm_vdw_energy=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -Ec "^tinker_mm_vdw_energy 1" | awk '{if($1>0) print "1"; else print "0";}'`
  if [ $opt_tinker_mm_vdw_energy == "1" ]; then
    echo "    (MM van der Waals energy from TINKER)"
  else
    echo "    (MM van der Waals energy NOT from TINKER)"
  fi

  opt_tinker_qm_mm_perm_energy=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -Ec "^tinker_qm_mm_perm_energy 1" | awk '{if($1>0) print "1"; else print "0";}'`
  if [ $opt_tinker_qm_mm_perm_energy == "1" ]; then
    echo "    (QM/MM Permanent multipole energy from TINKER)"
  else
    echo "    (QM/MM Permanent multipole energy NOT from TINKER)"
  fi

  opt_tinker_qm_mm_pol_energy=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -Ec "^tinker_qm_mm_pol_energy 1" | awk '{if($1>0) print "1"; else print "0";}'`
  if [ $opt_tinker_qm_mm_pol_energy == "1" ]; then
    echo "    (QM/MM Induced dipole energy from TINKER)"
  else
    echo "    (QM/MM Induced dipole energy NOT from TINKER)"
  fi

  opt_tinker_mm_perm_energy=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -Ec "^tinker_mm_perm_energy 1" | awk '{if($1>0) print "1"; else print "0";}'`
  if [ $opt_tinker_mm_perm_energy == "1" ]; then
    echo "    (MM Permanent multipole energy from TINKER)"
  else
    echo "    (MM Permanent multipole energy NOT from TINKER)"
  fi

  opt_tinker_mm_pol_energy=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -Ec "^tinker_mm_pol_energy 1" | awk '{if($1>0) print "1"; else print "0";}'`
  if [ $opt_tinker_mm_pol_energy == "1" ]; then
    echo "    (MM+ Induced dipole energy from TINKER)"
  else
    echo "    (MM+ Induced dipole energy NOT from TINKER)"
  fi

  if [ `cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -Ec "^onetep_perm_mpoles"` != 1 ]; then
    error "Setting 'onetep_perm_mpoles' is not defined, or is defined multiply, in $configfile" $err_config_file_directive_onetep_perm_mpoles
  fi
  opt_onetep_perm_mpoles=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -E "^onetep_perm_mpoles" | sed "s/onetep_perm_mpoles //"`
  echo "    (Permanent multipole treatment in ONETEP: $opt_onetep_perm_mpoles)"

  if [ `cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -Ec "^onetep_induced_dipoles"` != 1 ]; then
    error "Setting 'onetep_induced_dipoles' is not defined, or is defined multiply, in $configfile" $err_config_file_directive_onetep_induced_dipoles
  fi
  opt_onetep_induced_dipoles=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -E "^onetep_induced_dipoles" | sed "s/onetep_induced_dipoles //"`
  echo "    (Induced dipole treatment in ONETEP: $opt_onetep_induced_dipoles)"

  # Polarisabilities will be needed if Thole damping is used anywhere
  if echo "$opt_onetep_perm_mpoles" | grep -q thole || echo "$opt_onetep_induced_dipoles" | grep -q thole; then
    opt_polarisabilities_needed=1
  else
    opt_polarisabilities_needed=0
  fi

  opt_mm_fixed_charge=`cat $configfile | tr "\t" " " | sed -r "s/ +/ /g" | grep -Ec "^mm_fixed_charge" | awk '{if($1>0) print "1"; else print "0";}'`
  if [ $opt_mm_fixed_charge == "1" ]; then
    echo "    (MM uses a fixed-charge force-field)"
  else
    echo "    (MM uses a polarisable force-field)"
  fi
}

################################################################################
# main()
################################################################################

echo "*** $myname:"

rm -f "error_message"

parse_config

if [ $# -ne 1 ]; then
  error "Improper invocation. Supply a TINKER (qm_mm).xyz filename" $err_improper_invocation
fi

# Ensure input file exists
xyzf=$1
if [ ! -r $xyzf ]; then
  error "$xyzf does not exist or is not readable" $err_xyz_file_unreadable
fi

# Extract last four characters of input filename
xyzf_ext=`echo $xyzf | sed -r "s/.*(....)$/\1/"`

# Ensure they are as expected, for a safe replace later in determining
# the output filenames.
if [ "$xyzf_ext" != ".xyz" ]; then
  error "The extension of the input TINKER xyz file should be '.xyz'" $err_input_xyz_bad_extension
fi

# Extract last nine characters of input filename
xyzf_nametail=`echo $xyzf | sed -r "s/.*(.........)$/\1/"`

# Ensure they are as expected, for a safe replace later in determining
# the output filenames.
if [ "$xyzf_nametail" != "qm_mm.xyz" ]; then
  error "The input TINKER xyz file should be named according to '...qm_mm.xyz'. Otherwise there'd be confusion later on." $err_input_xyz_bad_nametail
fi

# Infer the name of the key file
keyf=`echo $xyzf | sed -r "s/\.xyz/.key/"`
orig_keyf="$keyf"".orig"

# Infer the names of the force files and the log sfile and the multipole file
forcef=`echo $xyzf | sed -r "s/\.xyz/.001f/"`
forcef_out=`echo $xyzf | sed -r "s/\.xyz/.f/"`
dynamiclogf=`echo $xyzf | sed -r "s/\.xyz/.dynamic_log/"`
analyzelogf=`echo $xyzf | sed -r "s/\.xyz/.analyze_log/"`
multpf=`echo $xyzf | sed -r "s/qm_mm\.xyz/mm.mpoles/"`
etermf=`echo $xyzf | sed -r "s/qm_mm\.xyz/mm.energy_terms/"`

# Ensure these are fine
if [ ! -r $keyf ]; then
  error "$keyf (inferred from $xyzf) does not exist or is not readable" $err_key_file_unreadable
fi
if [ -r $dynamiclogf ]; then
  error "$dynamiclogf (inferred from $xyzf) already exists, I'm afraid to overwrite it" $err_dynamic_log_already_exists
fi
if [ -r $analyzelogf ]; then
  error "$analyzelogf (inferred from $xyzf) already exists, I'm afraid to overwrite it" $err_analyze_log_already_exists
fi
if [ -r $multpf ]; then
  error "$multpf (inferred from $xyzf) already exists, I'm afraid to overwrite it" $err_multp_file_already_exists
fi
if [ -r $etermf ]; then
  error "$etermf (inferred from $xyzf) already exists, I'm afraid to overwrite it" $eterm_file_already_exists
fi

# Figure out the name of the param file and check it exists
FFparamfile=`cat $keyf | tr "\t" " " | sed -r "s/ +/ /g" | grep "parameters" | sed "s/parameters //"`".prm"
if [ -z "$FFparamfile" ]; then
  error "The directive 'parameters' is missing in TINKER key file $keyf " $err_key_missing_parameters
fi
if [ ! -r "$FFparamfile" ]; then
  error "The force-field parameter file '$FFparamfile' does not exist or is unreadable" $err_ff_param_file_unreadable
fi

# Extract the number of atoms from the TINKER xyz file and copy it to out force file
natoms=`head -n 1 $xyzf | sed -r "s/([0-9])\ /\1#/" | tr "#" "\n"`
echo $natoms >$forcef_out

# Stow away the original key file somewhere safe, we need its filename to store
# additional stuff into.
cp -a $keyf $orig_keyf

echo "PRINT_GLOBAL_MPOLES" >>$keyf
echo "save-force" >>$keyf
echo "save-velocity" >>$keyf

# Clean up any potential previous TINKER intermediate files
rm -f `echo $xyzf | sed -r "s/\.xyz/.0*/"`

# --------------------------
# --- Run TINKER/dynamic ---
# --------------------------
echo "    Running TINKER ($dynamicexe) $xyzf -> $dynamiclogf"
# ============================================================================================================================================
echo -e "1\n0.001\n0.000001\n1" | $dynamicexe $xyzf >$dynamiclogf
# ============================================================================================================================================
result=$?
if [ $result -ne 0 ]; then
  error "TINKER $dynamicexe did not run correctly (error code #$result). Maybe a missing FF parameter file?" $err_dynamic_error_code
fi
# --------------------------
echo "    ... Done"

if [ `cat $dynamiclogf | grep -v "$dummy_atom_symbol\-" | grep -v "\-$dummy_atom_symbol" | grep -cE "\*\*\*"` -gt 0 ]; then
  error "$dynamiclogf contains Fortran RTL asterisks indicating output overflow. It is very likely your system has exploded" $err_dynamic_asterisks_in_log
fi

if [ `cat $dynamiclogf | grep -v "$dummy_atom_symbol\-" | grep -v "\-$dummy_atom_symbol" | grep -cE "NaN"` -gt 0 ]; then
  error "$dynamiclogf contains at least one NaN. It is very likely your system has exploded" $err_dynamic_NaN_in_log
fi

# --------------------------
# --- Run TINKER/analyze ---
# --------------------------
echo "    Running TINKER ($analyzeexe) $xyzf -> $analyzelogf"
# ============================================================================================================================================
echo -e "d\n" | $analyzeexe $xyzf >$analyzelogf 2>&1 # stderr redirection works around TINKER bug that causes some info to be printed to stderr because of mishandled OMP
# ============================================================================================================================================
result=$?
if [ $result -ne 0 ]; then
  error "TINKER $analyzeexe did not run correctly (error code #$result). Maybe a missing FF parameter file?" $err_analyze_error_code
fi
# --------------------------

if [ `cat $analyzelogf | grep -c "Attempting to Renumber"` -gt 0 ]; then
  error "TINKER ($analyzeexe) reported it had to renumber atoms. This should not happen and would confuse later stages, so I cannot continue" $err_tinker_renumbered_atoms
fi

if [ `cat $analyzelogf | grep -v "$dummy_atom_symbol\-" | grep -v "\-$dummy_atom_symbol" | grep -cE "\*\*\*"` -gt 0 ]; then
  error "$analyzelogf contains Fortran RTL asterisks indicating output overflow. It is very likely your system has exploded" $err_analyze_asterisks_in_log
fi

if [ `cat $analyzelogf | grep -v "$dummy_atom_symbol\-" | grep -v "\-$dummy_atom_symbol" | grep -cE "NaN"` -gt 0 ]; then
  error "$analyzelogf contains at least one NaN. It is very likely your system has exploded" $err_analyze_NaN_in_log
fi


# Restore original key file
mv -f $orig_keyf $keyf

# Ensure dynamic ran correctly
if [ ! -r $forcef ]; then
  echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" >&2
  echo "Error running TINKER ($dynamicexe). Pasting the tail of the TINKER log file below." >&2
  echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" >&2
  tail $dynamiclogf | grep -v "#"
  error "$forcef does not exist. Probably '$dynamicexe' didn't run correctly" $err_tinker_dynamic_failed
fi

echo "    ... Done"
echo "    Extracting forces: $forcef -> $forcef_out"

# Extract forces
cat $forcef | sed "s/D/E/g" | awk -v unitconv=$force_conv_fac '{if(NR>1) printf("%-2s %14.7e %14.7e %14.7e\n",$2,$3*unitconv,$4*unitconv,$5*unitconv)}' >>$forcef_out
result=$?
if [ $result -ne 0 ]; then
  error "Failed to extract forces from $forcef." $err_extracting_forces
fi
echo "    ... Done"

# Arrange for the possibility of a BBox line in the .xyz file.
bbox_line=`xyz_bbox_line $xyzf` || error "Could not verify the presence of, or parse, the BBox line in the .xyz file $xyzf" $err_bbox
bbox_line_present=`echo $bbox_line | awk '{print ($4 > 0)}'`
let "firstatomline=2+bbox_line_present"

# Figure out the indices and species of MM atoms from the TINKER .xyz file
mm_indices=`tail -n +$firstatomline $xyzf | awk -v offset=$opt_renumber_offset '{if($6<=offset) print $1}'`
mm_species=`tail -n +$firstatomline $xyzf | awk -v offset=$opt_renumber_offset '{if($6<=offset) print $2}'`
echo $mm_indices >mm_indices
echo $mm_species >mm_species

# Ditto for QM atoms
qm_indices=`tail -n +$firstatomline $xyzf | awk -v offset=$opt_renumber_offset '{if($6>offset) print $1}'`
qm_species=`tail -n +$firstatomline $xyzf | awk -v offset=$opt_renumber_offset '{if($6>offset) print $2}'`
echo $qm_indices >qm_indices
echo $qm_species >qm_species

n_mm_atoms=`cat mm_indices | wc -w`
n_qm_atoms=`cat qm_indices | wc -w`

# Obtain polarisabilities of all MM atoms.
# This is technically O(N_MM^2), but should be fine -- as polarisabilities are fixed, it only runs once.
if [ $opt_polarisabilities_needed == 1 ]; then
  if [ ! -r "mm.polarisabilities" ]; then
    echo "    Determining MM atom polarisabilities"
    for n in `seq 1 $n_mm_atoms`; do
      mm_index=`cat mm_indices | awk -v n=$n '{print $n}'`
      nth_dipole_polarisability=`atom_number_to_polarisability $xyzf $opt_jobname".tag" $mm_index $FFparamfile | awk '{printf("%.9f",$1)}'`
      echo -n $mm_index $nth_dipole_polarisability " " >>mm.polarisabilities
    done
  else
    echo "    Re-using cached MM polarisabilities"
  fi
  n_mm_polarisabilities=`cat mm.polarisabilities | wc -w`
  let "expected_n_mm_polarisabilities=n_mm_atoms*2"
  if [ "$n_mm_polarisabilities" != "$expected_n_mm_polarisabilities" ]; then
    error "Failed to extract MM atom polarisabilities. Obtained $n_mm_polarisabilities, expected $expected_n_mm_polarisabilities" $err_extracting_mm_atom_polarisabilities
  fi
  echo "    ... Done"
else
  echo "    MM polarisabilities not needed -- no Thole damping in effect"
fi

# Obtain vdW params of all MM atoms.
# This is technically O(N_MM^2), but should be fine -- as these are fixed, it only runs once.
if [ ! -r "mm.vdwparams" ]; then
  echo "    Determining MM atom vdW parameters"
  for n in `seq 1 $n_mm_atoms`; do
    mm_index=`cat mm_indices | awk -v n=$n '{print $n}'`
    nth_vdwparams=`atom_number_to_vdw_params $xyzf $mm_index $FFparamfile | awk '{printf("%.9f %.9f",$1,$2)}'`
    echo -n $mm_index $nth_vdwparams " " >>mm.vdwparams
  done
else
  echo "    Re-using cached MM vdW parameters"
fi
n_mm_vdwparams=`cat mm.vdwparams | wc -w`
let "expected_n_mm_vdwparams=n_mm_atoms*3"
if [ "$n_mm_vdwparams" != "$expected_n_mm_vdwparams" ]; then
  error "Failed to extract MM atom vdW parameters. Obtained $n_mm_vdwparams, expected $expected_n_mm_vdwparams" $err_extracting_mm_atom_vdw_params
fi
echo "    ... Done"

# Extract permanent multipoles or fixed charges, depending on force field.
n_all_multipoles=`echo $natoms | awk '{print $1*13}'`
# If the FF is fixed-charge, there will be no multipoles in dynamic.log. 
# These must be faked from the data from the qm_mm.xyz file.
if [ "$opt_mm_fixed_charge" == "1" ]; then
  echo "    Extracting fixed charges from $keyf and $FFparamfile, to build multipoles for ONETEP"
  rm -f permanent_multipoles.raw
  # QM atoms -- extract charges from qm_mm.key file
  for QM_idx in $qm_indices; do
    charge=`atom_number_to_fixed_charge $xyzf $QM_idx $keyf`
    result=$?
    if [ $result -ne 0 ] && [ -z "$charge" ]; then
      error "Failed to extract fixed charge of QM atom $QM_idx from $keyf" $err_extracting_fixed_charge_QM
    fi
    ( echo "GLOBAL_MPOLE:        $QM_idx 1 $charge"
    echo "GLOBAL_MPOLE:        $QM_idx 2 0.0" # zero dipole
    echo "GLOBAL_MPOLE:        $QM_idx 3 0.0" # zero dipole
    echo "GLOBAL_MPOLE:        $QM_idx 4 0.0" # zero dipole
    echo "GLOBAL_MPOLE:        $QM_idx 5 0.0" # zero quadrupole
    echo "GLOBAL_MPOLE:        $QM_idx 6 0.0" # zero quadrupole
    echo "GLOBAL_MPOLE:        $QM_idx 7 0.0" # zero quadrupole
    echo "GLOBAL_MPOLE:        $QM_idx 8 0.0" # zero quadrupole
    echo "GLOBAL_MPOLE:        $QM_idx 9 0.0" # zero quadrupole
    echo "GLOBAL_MPOLE:        $QM_idx 10 0.0" # zero quadrupole
    echo "GLOBAL_MPOLE:        $QM_idx 11 0.0" # zero quadrupole
    echo "GLOBAL_MPOLE:        $QM_idx 12 0.0" # zero quadrupole
    echo "GLOBAL_MPOLE:        $QM_idx 13 0.0" ) >>permanent_multipoles.raw # zero quadrupole 
  done
  # MM atoms -- extract charges from .prm file
  for MM_idx in $mm_indices; do
    charge=`atom_number_to_fixed_charge $xyzf $MM_idx $FFparamfile`
    result=$?
    if [ $result -ne 0 ] && [ -z "$charge" ]; then
      error "Failed to extract fixed charge of MM atom $MM_idx from $FFparamfile" $err_extracting_fixed_charge_MM
    fi
    ( echo "GLOBAL_MPOLE:        $MM_idx 1 $charge"
    echo "GLOBAL_MPOLE:        $MM_idx 2 0.0" # zero dipole
    echo "GLOBAL_MPOLE:        $MM_idx 3 0.0" # zero dipole
    echo "GLOBAL_MPOLE:        $MM_idx 4 0.0" # zero dipole
    echo "GLOBAL_MPOLE:        $MM_idx 5 0.0" # zero quadrupole
    echo "GLOBAL_MPOLE:        $MM_idx 6 0.0" # zero quadrupole
    echo "GLOBAL_MPOLE:        $MM_idx 7 0.0" # zero quadrupole
    echo "GLOBAL_MPOLE:        $MM_idx 8 0.0" # zero quadrupole
    echo "GLOBAL_MPOLE:        $MM_idx 9 0.0" # zero quadrupole
    echo "GLOBAL_MPOLE:        $MM_idx 10 0.0" # zero quadrupole
    echo "GLOBAL_MPOLE:        $MM_idx 11 0.0" # zero quadrupole
    echo "GLOBAL_MPOLE:        $MM_idx 12 0.0" # zero quadrupole
    echo "GLOBAL_MPOLE:        $MM_idx 13 0.0" ) >>permanent_multipoles.raw # zero quadrupole 
  done

else
  # The usual (polarisable) scenario, where raw multipoles are extracted from TINKER log
  echo "    Extracting permanent multipoles from $dynamiclogf"
  cat $dynamiclogf | grep "GLOBAL_MPOLE: " | head -n $n_all_multipoles >permanent_multipoles.raw
fi

# Polarisable and fixed-charge branches merge here, continue processing multipoles.
n_actual_multipoles=`cat permanent_multipoles.raw | wc -l`
if [ "$n_actual_multipoles" != "$n_all_multipoles" ]; then
  error "Mismatch in the number of global multipoles extracted from TINKER. Expecting $n_all_multipoles, got $n_actual_multipoles. Perhaps your TINKER version does not support PRINT_GLOBAL_MPOLES?" $err_bad_multipole_count
fi

# Parse raw permanent multipoles and arrange them in the format ONETEP expects
cat permanent_multipoles.raw | awk -v unitconv=$dipole_conv_fac '
{
  atom=$2;
  if($3 == 1) {
    # Initate new atom - write charge
    q=$4;
    printf("%17.13f ",q);
  }
  if($3>=2 && $3<=4) {
    # Dipole component for this atom
    dipole=$4/unitconv;
    printf("%17.13f ",dipole);
  }
  if($3>=5 && $3<=13) {
    # Quadrupole component for this atom
    quadrupole=$4/unitconv/unitconv;
    quadrupole=2.0*quadrupole; # Quadrupole convention juggling. 
    printf("%17.13f ",quadrupole);
  }
  if($3 == 13) {
    # Finalise this atom
    printf("\n");
  }
}' >permanent_multipoles.processed.1
result=$?
if [ $result -ne 0 ]; then
  error "Failed to extract MM permanent multipoles from $dynamiclogf" $err_extracting_permanent_multipoles
fi

# Extract raw atomic positions from the TINKER .xyz file
tail -n +$firstatomline $xyzf | awk '{printf("%25.13f %25.13f %25.13f",$3,$4,$5)}' >positions.raw
result=$?
if [ $result -ne 0 ]; then
  error "Failed to extract atomic positions from $xyzf" $err_extracting_atomic_positions
fi

# Further process the multipoles to retain only MM atoms and to add species in the first column
# Careful. This is technically O(N_MM^2).
# Also add positions at the front.
echo "Unrecognized error" >"error_message"
cat permanent_multipoles.processed.1 | awk -v opt_onetep_perm_mpoles="$opt_onetep_perm_mpoles" -v opt_polarisabilities_needed="$opt_polarisabilities_needed" -v bohr2ang=$bohr2ang -v kcal2au=$energy_conv_fac '
BEGIN{
  getline mm_indices < "mm_indices";
  getline mm_species < "mm_species";
  getline qm_indices < "qm_indices";
  getline qm_species < "qm_species";
  getline all_positions < "positions.raw"
  n_mm_indices=split(mm_indices,mm_indices_arr," ");
  n_mm_species=split(mm_species,mm_species_arr," ");
  n_qm_indices=split(qm_indices,qm_indices_arr," ");
  n_qm_species=split(qm_species,qm_species_arr," ");
  n_tot_species=n_qm_species+n_mm_species;
  n_tot_indices=n_qm_indices+n_mm_indices;
  n_all_positions=split(all_positions,all_positions_arr," ");
  if(n_mm_indices != n_mm_species) {
    printf("Mismatch between the number of MM indices and MM species while parsing MM multipoles: %d != %d",n_mm_indices,n_mm_species) >"error_message";
    exit 11;
  }
  if(n_qm_indices != n_qm_species) {
    printf("Mismatch between the number of QM indices and QM species while parsing QM multipoles: %d != %d",n_qm_indices,n_qm_species) >"error_message";
    exit 12;
  }
  printf("multipoles %d %s\n",n_tot_indices,opt_onetep_perm_mpoles);

  if(opt_polarisabilities_needed == 1) {
    getline indices_and_polarisabilities < "mm.polarisabilities"
    nentries=split(indices_and_polarisabilities,indices_and_polarisabilities_arr," ");
    for(i=1;i<=nentries;i+=2) {
      idx2polarisability[indices_and_polarisabilities_arr[i]] = indices_and_polarisabilities_arr[i+1];
    }
  }

  getline indices_and_vdw_params < "mm.vdwparams"
  nentries=split(indices_and_vdw_params,indices_and_vdw_params_arr," ");
  for(i=1;i<=nentries;i+=3) {
    idx2vdw_rmin[indices_and_vdw_params_arr[i]] = indices_and_vdw_params_arr[i+1];
    idx2vdw_eps[indices_and_vdw_params_arr[i]] = indices_and_vdw_params_arr[i+2];
  }

}
{
  atom_idx=NR;
  is_mm_atom=0;
  for(i=1; i<=n_mm_indices; ++i) {
    if(atom_idx == mm_indices_arr[i]) {
      is_mm_atom=1;
      mm_atom_idx++;
      break;
    }
  }

  x=all_positions_arr[(atom_idx-1)*3+1];
  y=all_positions_arr[(atom_idx-1)*3+2];
  z=all_positions_arr[(atom_idx-1)*3+3];

  if(is_mm_atom == 0) {
    qm_atom_idx++;
  }

  if(is_mm_atom) {
    # --- MM multipoles ---
    if(mm_atom_idx > n_mm_indices) {
      printf("Book-keeping error while parsing MM-side MM multipoles: %d != %d: %s",mm_atom_idx,n_mm_indices,$0) >"error_message";
      exit 13;
    }
    printf("%-4s %25.13f %25.13f %25.13f %s %17.12f %20.9f %20.9f\n",mm_species_arr[mm_atom_idx],x,y,z,$0,idx2polarisability[mm_indices_arr[mm_atom_idx]]/bohr2ang/bohr2ang/bohr2ang,idx2vdw_rmin[mm_indices_arr[mm_atom_idx]]/bohr2ang,idx2vdw_eps[mm_indices_arr[mm_atom_idx]]*kcal2au);
    mm_atoms_written++;
  }
  else {
    # --- QM multipoles ---
    if(qm_atom_idx > n_qm_indices) {
      printf("Book-keeping error while parsing MM-side QM multipoles: %d != %d: %s",qm_atom_idx,n_qm_indices,$0) >"error_message";
      exit 14;
    }
    printf("%-4s %25.13f %25.13f %25.13f %s %17.12f %20.9f %20.9f\n","#"qm_species_arr[qm_atom_idx],x,y,z,$0,0.0,0.0,0.0); # last three 0.0 are polarisability and vdW params, which are zero for QM multipoles
    qm_atoms_written++;
  }
}
END {
  if(mm_atoms_written != n_mm_indices) {
    printf("Mismatch between the number of MM multipoles written and the number expected to write while parsing MM-side multipoles: %d != %d",mm_atoms_written,n_indices) >"error_message";
    exit 15;
  }
  if(qm_atoms_written != n_qm_indices) {
    printf("Mismatch between the number of QM multipoles written and the number expected to write while parsing MM-side multipoles: %d != %d",mm_atoms_written,n_indices) >"error_message";
    exit 16;
  }
}
' >permanent_multipoles.processed.2
result=$?
if [ $result -ne 0 ]; then
  errmsg=`cat error_message`
  error "Failed to process MM-side permanent multipoles from $dynamiclogf: $errmsg" $err_processing_permanent_multipoles
else
  rm -f "error_message"
fi
echo "    ... Done"

# Deal with induced dipoles only if force field is not fixed-charge.
if [ "$opt_mm_fixed_charge" == "0" ]; then 
  echo "    Extracting induced dipoles: $dynamiclogf"

  # Extract raw induced dipoles from TINKER dynamic log
  header_length=4
  if [ $opt_qm_polarisability == "1" ]; then
    let "n_lines_of_interest=n_qm_atoms+n_mm_atoms+header_length"
  else
    let "n_lines_of_interest=n_mm_atoms+header_length"
  fi
  echo "Unrecognized error" >"error_message"
  cat $dynamiclogf | grep -A$n_lines_of_interest "Induced Dipole Moments (Debyes)" | \
  awk -v n_mm_atoms=$n_mm_atoms -v n_qm_atoms=$n_qm_atoms -v n_lines_of_interest=$n_lines_of_interest -v header_length=$header_length '
  {
    if(NR>header_length && NR<=n_lines_of_interest) {
      if(NF != 5) {
        printf("Error extracting raw induced dipoles, they are misplaced or misformatted or my idea of the number of QM atoms or MM atoms is wrong. %d %s",NF,$0) >"error_message";
        exit 11;
      }
      printf("%17.13f %17.13f %17.13f %d ",$2,$3,$4,$1); # space after %d is crucial
    }
    if(NR==n_lines_of_interest+1) {
      if(NF != 0) {
        printf("Error extracting raw induced dipoles, there are more than expected. Expected %d MM atoms and %d QM atoms. Offending line:\n===%s\n===",n_mm_atoms,n_qm_atoms,$0) >"error_message";
        exit 12;
      }
    }
  }' >induced_dipoles.raw
  result=$?
  if [ $result -ne 0 ]; then
    errmsg=`cat error_message`
    if [ $opt_qm_polarisability == "1" ]; then
      error "Failed to process QM+MM induced dipoles from $dynamiclogf: $errmsg. Perhaps a missing 'debug' in key file?" $err_processing_induced_qm_mm_dipoles_1
    else
      error "Failed to process MM induced dipoles from $dynamiclogf: $errmsg. Perhaps a missing 'debug' in key file?" $err_processing_induced_mm_dipoles_1
    fi
  else
    rm -f "error_message"
  fi

  # Replace the indices with polarisabilities
  cat induced_dipoles.raw | awk -v opt_polarisabilities_needed="$opt_polarisabilities_needed" '
  BEGIN {
    if(opt_polarisabilities_needed) {
       getline indices_and_polarisabilities < "mm.polarisabilities"
       nentries=split(indices_and_polarisabilities,indices_and_polarisabilities_arr," ");
       for(i=1;i<=nentries;i+=2) {
         idx2polarisability[indices_and_polarisabilities_arr[i]] = indices_and_polarisabilities_arr[i+1];
       }
    }
  }
  {
    for(i=1;i<=NF;++i) {
      if(i%4 != 0) {
        printf("%17.13f ",$i); # copy over dipole components
      }
      else {
        printf("%14.9f ",idx2polarisability[$i]);
      }
    }
  }
  ' >induced_dipoles_and_polarisabilities.raw

  # Convert induced dipoles to ONETEP form -- add species and positions
  echo "Unrecognized error" >"error_message"
  tail -n +$firstatomline $xyzf | awk -v unitconv=$induced_dipole_conv_fac -v bohr2ang=$bohr2ang -v kcal2au=$energy_conv_fac -v n_mm_atoms=$n_mm_atoms -v n_qm_atoms=$n_qm_atoms -v opt_qm_polarisability=$opt_qm_polarisability -v opt_onetep_induced_dipoles="$opt_onetep_induced_dipoles" '
  BEGIN{
    getline mm_indices < "mm_indices";
    n_mm_indices=split(mm_indices,mm_indices_arr," ");
    getline mm_induced_dipoles < "induced_dipoles_and_polarisabilities.raw"
    getline all_positions < "positions.raw"
    n_dipole_components=split(mm_induced_dipoles,mm_induced_dipoles_arr," ");
    n_all_positions=split(all_positions,all_positions_arr," ");
    if(opt_qm_polarisability) {
      n_atoms=n_qm_atoms+n_mm_atoms
      if(n_atoms*4 != n_dipole_components) {
        printf("Mismatch between the number of QM+MM atoms and QM+MM induced dipole components while parsing QM+MM induced dipoles. Expected QM atoms: %d. Expected MM atoms: %d. Obtained dipole components: %d",n_qm_atoms,n_mm_atoms,n_dipole_components) >"error_message";
        exit 11;
      }
      if(n_atoms*3 != n_all_positions) {
        printf("Mismatch between the number of QM+MM atoms and QM+MM atom positions while parsing QM+MM induced dipoles. Expected QM atoms: %d. Expected MM atoms: %d. Obtained QM+MM positions: %d",n_qm_atoms,n_mm_atoms,n_all_positions) >"error_message";
        exit 12;
      }
    }
    else {
      n_atoms=n_mm_atoms
      if(n_atoms*4 != n_dipole_components) {
        printf("Mismatch between the number of MM atoms and MM induced dipole components while parsing MM induced dipoles. Expected MM atoms: %d. Obtained dipole components: %d",n_mm_atoms,n_dipole_components) >"error_message";
        exit 13;
      }
      if(n_atoms*3 != n_all_positions) {
        printf("Mismatch between the number of MM atoms and MM atom positions while parsing MM induced dipoles. Expected MM atoms: %d. Obtained MM positions: %d",n_mm_atoms,n_all_positions) >"error_message";
        exit 14;
      }
    }

    getline indices_and_vdw_params < "mm.vdwparams"
    nentries=split(indices_and_vdw_params,indices_and_vdw_params_arr," ");
    for(i=1;i<=nentries;i+=3) {
      idx2vdw_rmin[indices_and_vdw_params_arr[i]] = indices_and_vdw_params_arr[i+1];
      idx2vdw_eps[indices_and_vdw_params_arr[i]] = indices_and_vdw_params_arr[i+2];
    }

    printf("multipoles %d %s\n",n_atoms,opt_onetep_induced_dipoles);
  }
  {
      atom_idx=NR;
      is_mm_atom=0;
      for(i=1; i<=n_mm_indices; ++i) {
        if(atom_idx == mm_indices_arr[i]) {
          is_mm_atom=1;
          break;
        }
      }
      species=$2;
      x=$3;
      y=$4;
      z=$5;
      induced_mx=mm_induced_dipoles_arr[(atom_idx-1)*4+1] * unitconv;
      induced_my=mm_induced_dipoles_arr[(atom_idx-1)*4+2] * unitconv;
      induced_mz=mm_induced_dipoles_arr[(atom_idx-1)*4+3] * unitconv;
      polarisability=mm_induced_dipoles_arr[(atom_idx-1)*4+4] / bohr2ang / bohr2ang / bohr2ang; # Convert polarisability to bohr^3.
      #          sp   x       y       z       q      mx      my      mz      Qxx     Qxy     Qxz     Qyx     Qyy     Qyz     Qzx     Qzy     Qzz     alpha vdW_Rmin vdW_eps
      if(is_mm_atom) {
        printf("%-4s %25.13f %25.13f %25.13f %17.13f %17.13f %17.13f %17.13f %17.13f %17.13f %17.13f %17.13f %17.13f %17.13f %17.13f %17.13f %17.13f %17.12f %20.9f %20.9f\n",species,x,y,z,0.0,induced_mx,induced_my,induced_mz,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,polarisability,idx2vdw_rmin[atom_idx]/bohr2ang,idx2vdw_eps[atom_idx]*kcal2au);
      }
      else {
        printf("%-4s %25.13f %25.13f %25.13f %17.13f %17.13f %17.13f %17.13f %17.13f %17.13f %17.13f %17.13f %17.13f %17.13f %17.13f %17.13f %17.13f %17.12f %20.9f %20.9f\n","#"species,x,y,z,0.0,induced_mx,induced_my,induced_mz,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,polarisability,0.0,0.0);
      }
  }' >induced_dipoles.processed
  result=$?
  if [ $result -ne 0 ]; then
    errmsg=`cat error_message`
    if [ $opt_qm_polarisability == "1" ]; then
      error "Failed to process QM+MM induced dipoles from $dynamiclogf: $errmsg" $err_processing_induced_qm_mm_dipoles_2
    else
      error "Failed to process MM induced dipoles from $dynamiclogf: $errmsg" $err_processing_induced_mm_dipoles_2
    fi
  else
    rm -f "error_message"
  fi
  echo "    ... Done"
fi # If having induced dipoles at all

echo "    Extracting TINKER energy terms $analyzelogf -> $etermf"
rm -f $etermf
# --- CAVEAT ---
# When adding further energy terms, be really sure you're extracting the appropriate column.
# For instance "Angle Bending" requires extracting $3, but "Polarization" requires $2.

# --- Bond stretch ---
if [ $opt_tinker_bond_energy == "1" ]; then
  Ebond=`cat $analyzelogf | grep "Bond Stretching  " | awk -v unitconv=$energy_conv_fac '{printf("%24.14f\n",$3*unitconv)}'`
  result=$?
  if [ $result -ne 0 ] || [ -z "$Ebond" ]; then
    error "Failed to extract Bond Stretching energy from $analyzelogf" $err_extracting_bond_energy
  fi
  echo "    - Bond Stretching energy:           $Ebond Ha"
  echo "MMv bond stretch:    $Ebond" >>$etermf
fi

# --- Angle bend ---
if [ $opt_tinker_angle_energy == "1" ]; then
  if [ $n_mm_atoms -gt 2 ]; then
    Eang=`cat $analyzelogf | grep "Angle Bending  " | awk -v unitconv=$energy_conv_fac '{printf("%24.14f\n",$3*unitconv)}'`
    result=$?
    if [ $result -ne 0 ] || [ -z "$Eang" ]; then
      error "Failed to extract Angle Bending energy from $analyzelogf" $err_extracting_angle_energy
    fi
  else
    Eang=0.0
  fi
  echo "    - Angle Bending energy:             $Eang Ha"
  echo "MMv angle bend:      $Eang" >>$etermf
fi

# --- Urey-Bradley ---
if [ $opt_tinker_ureybrad_energy == "1" ]; then
  Eureybrad=`cat $analyzelogf | grep "Urey-Bradley  " | awk -v unitconv=$energy_conv_fac '{printf("%24.14f\n",$2*unitconv)}'`
  result=$?
  if [ $result -ne 0 ] || [ -z "$Ebond" ]; then
    error "Failed to extract Urey-Bradley energy from $analyzelogf" $err_extracting_ureybrad_energy
  fi
  echo "    - Urey-Bradley energy:              $Ebond Ha"
  echo "MMv Urey-Bradley:    $Eureybrad" >>$etermf
fi

# --- Electrostatics ---
echo "Unrecognized error" >"error_message"
if [ "$opt_mm_fixed_charge" == "1" ]; then
  termname=" Charge " # Don't remove these spaces, or you'll grep extra lines!
else
  termname="M-Pole"
fi
#cat $analyzelogf | grep $termname | grep -v "$dummy_atom_symbol\-" | grep -v "\-$dummy_atom_symbol" | awk -v opt_mm_fixed_charge=$opt_mm_fixed_charge '
cat $analyzelogf | grep $termname | awk -v opt_mm_fixed_charge=$opt_mm_fixed_charge '
BEGIN{
  getline qm_indices < "qm_indices";
  n_qm_indices=split(qm_indices,qm_indices_arr," ");
}
{
  split($2,atom1_str,"-");
  split($3,atom2_str,"-");
  atom1=atom1_str[1];
  atom2=atom2_str[1];

  # Check if atom1 is in QM region
  if(qm_atom_cache[atom1] == 1) {
    is_atom1_qm=1;
  }
  else if(qm_atom_cache[atom1] == 2) {
    is_atom1_qm=0;
  }
  else {
    is_atom1_qm=0;
    for(i=1; i<=n_qm_indices; ++i) {
      qm_atom_idx=qm_indices_arr[i];
      if(atom1 == qm_atom_idx) {
        is_atom1_qm=1;
        qm_atom_cache[atom1] = 1;
        break;
      }
    }
    if(qm_atom_cache[atom1] != 1) qm_atom_cache[atom1] = 2;
  }

  # Check if atom2 is in QM region
  if(qm_atom_cache[atom2] == 1) {
    is_atom2_qm=1;
  }
  else if(qm_atom_cache[atom2] == 2) {
    is_atom2_qm=0;
  }
  else {
    is_atom2_qm=0;
    for(i=1; i<=n_qm_indices; ++i) {
      qm_atom_idx=qm_indices_arr[i];
      if(atom2 == qm_atom_idx) {
        is_atom2_qm=1;
        qm_atom_cache[atom2] = 1;
        break;
      }
    }
    if(qm_atom_cache[atom2] != 1) qm_atom_cache[atom2] = 2;
  }
  
  # If both atoms in QM, something is wrong.
  # TINKER should not be calculating QM/QM electrostatics
  if(is_atom1_qm && is_atom2_qm) {
    printf("Unexpected QM/QM interaction in TINKER electrostatics: %s",$0) >"error_message";
    exit 11;
  }
  
  # If one atom in QM, and one in MM, add this to QM/MM total
  if((is_atom1_qm && ! is_atom2_qm ) || (is_atom2_qm && ! is_atom1_qm)) {
    if(opt_mm_fixed_charge) {
      qm_mm_perm+=$7;
    }
    else {
      qm_mm_perm+=$5;
      qm_mm_pol+=$6;
    }
  }
  
  # If neither atom in QM, add this to MM total
  if(( ! is_atom1_qm ) && (! is_atom2_qm )) {
    if(opt_mm_fixed_charge) {
      mm_perm+=$7;
    }
    else {
      mm_perm+=$5;
      mm_pol+=$6;
    }
  }
}
END {
  printf("%24.14f %24.14f %24.14f %24.14f",qm_mm_perm,qm_mm_pol,mm_perm,mm_pol) >"electrostatic_terms"
}
'
if [ $result -ne 0 ]; then
  errmsg=`cat error_message`
  error "Failed to extract detailed electrostatic interactions from $analyzelogf: $errmsg" $err_processing_electrostatics
else
  rm -f "error_message"
fi
n_electrostatic_terms=`cat electrostatic_terms | wc -w`
if [ "$n_electrostatic_terms" != "4" ]; then
  error "Something went wrong when extracting electrostatic terms from $analyzelogf. Expected 4 terms, got $n_electrostatic_terms" $err_in_number_of_electrostatics_terms
fi
Eperm_qm_mm=`cat electrostatic_terms | awk -v unitconv=$energy_conv_fac '{printf("%24.14f",$1*unitconv)}'`
Epol_qm_mm=`cat electrostatic_terms | awk -v unitconv=$energy_conv_fac '{printf("%24.14f",$2*unitconv)}'`
Eperm_mm=`cat electrostatic_terms | awk -v unitconv=$energy_conv_fac '{printf("%24.14f",$3*unitconv)}'`
Epol_mm=`cat electrostatic_terms | awk -v unitconv=$energy_conv_fac '{printf("%24.14f",$4*unitconv)}'`
rm -f electrostatic_terms

# --- Permanent multipole interaction (QM/MM) ---
if [ $opt_tinker_qm_mm_perm_energy == "1" ]; then
  echo "    - QM/MM Atomic Multipoles energy:   $Eperm_qm_mm Ha"
  echo "QM/MM perm mpole:    $Eperm_qm_mm" >>$etermf
else
  echo "    - QM/MM Atomic Multipoles energy:   $Eperm_qm_mm Ha (will be ignored in ONETEP)"
  echo "#QM/MM perm mpole:   $Eperm_qm_mm" >>$etermf
fi

# --- Polarisation interaction (QM/MM) ---
if [ $opt_tinker_qm_mm_pol_energy == "1" ]; then
  echo "    - QM/MM Polarisation energy:        $Epol_qm_mm Ha"
  echo "QM/MM polarisation:  $Epol_qm_mm" >>$etermf
else
  echo "    - QM/MM Polarisation energy:        $Epol_qm_mm Ha (will be ignored in ONETEP)"
  echo "#QM/MM polarisation: $Epol_qm_mm" >>$etermf
fi

# --- Permanent multipole interaction (purely MM) ---
if [ $opt_tinker_mm_perm_energy == "1" ]; then
  echo "    - MM Atomic Multipoles energy:      $Eperm_mm Ha"
  echo "MM perm mpole:       $Eperm_mm" >>$etermf
else
  echo "    - MM Atomic Multipoles energy:      $Eperm_mm Ha (will be ignored in ONETEP)"
  echo "#MM perm mpole:      $Eperm_mm" >>$etermf
fi

# --- Polarisation interaction (between MM atoms, but MM dipoles influenced by QM) ---
if [ $opt_tinker_mm_pol_energy == "1" ]; then
  echo "    - MM+ Polarisation energy:          $Epol_mm Ha"
  echo "MM+ polarisation:    $Epol_mm" >>$etermf
else
  echo "    - MM+ Polarisation energy:          $Epol_mm Ha (will be ignored in ONETEP)"
  echo "#MM+ polarisation:   $Epol_mm" >>$etermf
fi

# --- Non-electrostatic terms ---
echo "Unrecognized error" >"error_message"
cat $analyzelogf | grep "VDW\-" | awk '
BEGIN{
  getline qm_indices < "qm_indices";
  n_qm_indices=split(qm_indices,qm_indices_arr," ");
}
{
  split($2,atom1_str,"-");
  split($3,atom2_str,"-");
  atom1=atom1_str[1];
  atom2=atom2_str[1];

  # Check if atom1 is in QM region
  if(qm_atom_cache[atom1] == 1) {
    is_atom1_qm=1;
  }
  else if(qm_atom_cache[atom1] == 2) {
    is_atom1_qm=0;
  }
  else {
    is_atom1_qm=0;
    for(i=1; i<=n_qm_indices; ++i) {
      qm_atom_idx=qm_indices_arr[i];
      if(atom1 == qm_atom_idx) {
        is_atom1_qm=1;
        qm_atom_cache[atom1] = 1;
        break;
      }
    }
    if(qm_atom_cache[atom1] != 1) qm_atom_cache[atom1] = 2;
  }

  # Check if atom2 is in QM region
  if(qm_atom_cache[atom2] == 1) {
    is_atom2_qm=1;
  }
  else if(qm_atom_cache[atom2] == 2) {
    is_atom2_qm=0;
  }
  else {
    is_atom2_qm=0;
    for(i=1; i<=n_qm_indices; ++i) {
      qm_atom_idx=qm_indices_arr[i];
      if(atom2 == qm_atom_idx) {
        is_atom2_qm=1;
        qm_atom_cache[atom2] = 1;
        break;
      }
    }
    if(qm_atom_cache[atom2] != 1) qm_atom_cache[atom2] = 2;
  }
  
  # If both atoms in QM, something is wrong.
  # TINKER should not be calculating QM/QM terms
  if(is_atom1_qm && is_atom2_qm) {
    printf("Unexpected QM/QM interaction in TINKER non-electrostatic terms: %s",$0) >"error_message";
    exit 11;
  }
  
  # If one atom in QM, and one in MM, add this to QM/MM total
  if((is_atom1_qm && ! is_atom2_qm ) || (is_atom2_qm && ! is_atom1_qm)) {
    qm_mm_vdw_rep+=$7;
    qm_mm_vdw_disp+=$8;
  }
  
  # If neither atom in QM, add this to MM total
  if(( ! is_atom1_qm ) && (! is_atom2_qm )) {
    mm_vdw_rep+=$7;
    mm_vdw_disp+=$8;
  }
}
END {
  printf("%24.14f %24.14f %24.14f %24.14f", qm_mm_vdw_rep, mm_vdw_rep, qm_mm_vdw_disp ,mm_vdw_disp) >"non_electrostatic_terms"
}
'
if [ $result -ne 0 ]; then
  errmsg=`cat error_message`
  error "Failed to extract detailed non-electrostatic interactions from $analyzelogf: $errmsg" $err_processing_non_electrostatics
else
  rm -f "error_message"
fi
n_non_electrostatic_terms=`cat non_electrostatic_terms | wc -w`
if [ "$n_non_electrostatic_terms" != "4" ]; then
  error "Something went wrong when extracting non-electrostatic terms from $analyzelogf. Expected 4 terms, got $n_non_electrostatic_terms" $err_in_number_of_non_electrostatics_terms
fi

Evdw_qm_mm_rep=`cat non_electrostatic_terms | awk -v unitconv=$energy_conv_fac '{printf("%24.14f",$1*unitconv)}'`
Evdw_mm_rep=`cat non_electrostatic_terms | awk -v unitconv=$energy_conv_fac '{printf("%24.14f",$2*unitconv)}'`
Evdw_qm_mm_disp=`cat non_electrostatic_terms | awk -v unitconv=$energy_conv_fac '{printf("%24.14f",$3*unitconv)}'`
Evdw_mm_disp=`cat non_electrostatic_terms | awk -v unitconv=$energy_conv_fac '{printf("%24.14f",$4*unitconv)}'`
rm -f non_electrostatic_terms

# --- van der Waals interaction (QM/MM) ---
if [ $opt_tinker_qm_mm_vdw_energy == "1" ] || [ $opt_tinker_qm_mm_vdw_energy == "3" ]; then
  echo "    - QM/MM repulsive vdW energy:       $Evdw_qm_mm_rep Ha"
  echo "QM/MM vdW-rep:       $Evdw_qm_mm_rep" >>$etermf
else
  echo "    - QM/MM repulsive vdW energy:       $Evdw_qm_mm_rep Ha (will be ignored in ONETEP)"
  echo "#QM/MM vdW-rep:       $Evdw_qm_mm_rep" >>$etermf
fi

if [ $opt_tinker_qm_mm_vdw_energy == "1" ] || [ $opt_tinker_qm_mm_vdw_energy == "2" ]; then
  echo "    - QM/MM dispersive vdW energy:      $Evdw_qm_mm_disp Ha"
  echo "QM/MM vdW-disp:      $Evdw_qm_mm_disp" >>$etermf
else
  echo "    - QM/MM dispersive vdW energy:      $Evdw_qm_mm_disp Ha (will be ignored in ONETEP)"
  echo "#QM/MM vdW-disp:      $Evdw_qm_mm_disp" >>$etermf
fi

# --- van der Waals interaction (MM) ---
if [ $opt_tinker_mm_vdw_energy == "1" ]; then
  echo "    - MM repulsive vdW energy:          $Evdw_mm_rep Ha"
  echo "MM vdW-rep:          $Evdw_mm_rep" >>$etermf
  echo "    - MM dispersive vdW energy:         $Evdw_mm_disp Ha"
  echo "MM vdW-disp:         $Evdw_mm_disp" >>$etermf
else
  echo "    - MM repulsive vdW energy:          $Evdw_mm_rep Ha (will be ignored in ONETEP)"
  echo "#MM vdW-rep:         $Evdw_mm_rep" >>$etermf
  echo "    - MM dispersive vdW energy:         $Evdw_mm_disp Ha (will be ignored in ONETEP)"
  echo "#MM vdW-disp:        $Evdw_mm_disp" >>$etermf
fi

echo "    Combining energy terms, permanent multipoles and induced dipoles into a ONETEP input -> $multpf"
if [ "$opt_mm_fixed_charge" == "1" ]; then
  cat $etermf permanent_multipoles.processed.2 >$multpf
else
  cat $etermf permanent_multipoles.processed.2 induced_dipoles.processed >$multpf
fi
result=$?
if [ $result -ne 0 ]; then
  error "Failed to combine the energy term and multipole files" $err_combining_mpole_files
fi
echo "    ... Done"

# Clean up temporary files
rm -f `echo $xyzf | sed -r "s/\.xyz/.0*/"`
rm -f `echo $xyzf | sed -r "s/\.xyz/.dyn/"`
rm -f induced_dipoles.raw
# rm -f mm.polarisabilities (now serves as cache)
rm -f induced_dipoles_and_polarisabilities.raw
rm -f induced_dipoles.processed
rm -f permanent_multipoles.raw
rm -f permanent_multipoles.processed.1
rm -f permanent_multipoles.processed.2
rm -f positions.raw
rm -f mm_indices
rm -f mm_species
rm -f qm_indices
rm -f qm_species
rm -f $etermf # Pasted into multpf already

echo "    SUCCESS"
